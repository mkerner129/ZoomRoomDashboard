<script>
  // ====== CONFIG ======
  const LOCATION = { lat: 33.8366, lon: -117.9143, tz: "America/Los_Angeles", label: "Anaheim, California" };

  // ✅ Keep hourly tiles + precip bars perfectly aligned
  const SLOTS = 12; // change once, affects both sections

  // Unique IDs for inline SVG gradients (prevents “grey icons” from ID collisions)
  let __svgId = 0;

  function showFatal(err) {
    console.error(err);
    const div = document.createElement("div");
    div.style.position = "fixed";
    div.style.inset = "12px";
    div.style.zIndex = "99999";
    div.style.background = "#0b1a33";
    div.style.border = "1px solid rgba(255,255,255,.25)";
    div.style.borderRadius = "16px";
    div.style.padding = "14px 16px";
    div.style.color = "white";
    div.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial";
    div.style.boxShadow = "0 18px 44px rgba(0,0,0,.45)";
    div.innerHTML =
      '<div style="font-weight:900;letter-spacing:.4px;text-transform:uppercase;">Weather Board Error</div>' +
      '<div style="opacity:.85;margin-top:8px;font-size:13px;line-height:1.35;">' +
      String(err && err.message ? err.message : err) +
      '</div>' +
      '<div style="opacity:.75;margin-top:10px;font-size:12px;">Open DevTools Console to see full details.</div>';
    document.body.appendChild(div);
  }

  function el(id){
    const node = document.getElementById(id);
    if(!node) throw new Error("Missing element #" + id);
    return node;
  }

  function tickClock(){
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,'0');
    const mm = String(d.getMinutes()).padStart(2,'0');
    el('clock').childNodes[0].textContent = `${hh}:${mm}\n      `;
    el('clockDate').textContent =
      d.toLocaleDateString([], { weekday:'long', month:'short', day:'numeric' }).toUpperCase();
  }

  // ✅ Updated: uses CSS var --slots instead of hard-coded 12
  function setNowLineToFirstBar(){
    const line = document.getElementById("nowLine");
    if(!line) return;
    line.style.left = `calc(10px + (100% - 20px) / var(--slots) * 0.5)`;
  }

  // ✅ Updated: normalize weather_code to number and never fall back to grey square
  function svgFor(code, size=110){
    __svgId += 1;
    const uid = __svgId;

    const wc = Number(code);

    const base = (inner) =>
      `<svg width="${size}" height="${size}" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg">${inner}</svg>`;

    const partlyFallback = () => base(`
      <defs>
        <radialGradient id="sun2_${uid}" cx="35%" cy="35%" r="70%">
          <stop offset="0" stop-color="#FFF1B0"/>
          <stop offset="1" stop-color="#FFB020"/>
        </radialGradient>
        <linearGradient id="cloud_${uid}" x1="0" x2="1">
          <stop offset="0" stop-color="#EAF2FF"/>
          <stop offset="1" stop-color="#BFD8FF"/>
        </linearGradient>
      </defs>
      <circle cx="22" cy="24" r="10" fill="url(#sun2_${uid})"/>
      <g fill="url(#cloud_${uid})">
        <ellipse cx="38" cy="34" rx="18" ry="10"/>
        <ellipse cx="24" cy="38" rx="14" ry="8"/>
      </g>
    `);

    if (!Number.isFinite(wc)) return partlyFallback();

    const fog=[45,48], drizzle=[51,53,55,56,57], rain=[61,63,65,66,67,80,81,82],
          snow=[71,73,75,77,85,86], thunder=[95,96,99];

    let kind="clear";
    if(fog.includes(wc)) kind="fog";
    else if(drizzle.includes(wc)) kind="drizzle";
    else if(rain.includes(wc)) kind="rain";
    else if(snow.includes(wc)) kind="snow";
    else if(thunder.includes(wc)) kind="thunder";
    else if(wc===2||wc===3||wc===1) kind="partly";

    if(kind==="clear") return base(`
      <defs>
        <radialGradient id="sun_${uid}" cx="35%" cy="35%" r="70%">
          <stop offset="0" stop-color="#FFF1B0"/>
          <stop offset="1" stop-color="#FFB020"/>
        </radialGradient>
      </defs>
      <circle cx="32" cy="32" r="14" fill="url(#sun_${uid})"/>
      <g stroke="#FFCF5A" stroke-width="2" stroke-linecap="round" opacity=".95">
        <path d="M32 8v6"/><path d="M32 50v6"/><path d="M8 32h6"/><path d="M50 32h6"/>
        <path d="M14 14l4 4"/><path d="M46 46l4 4"/><path d="M46 18l4-4"/><path d="M14 50l4-4"/>
      </g>
    `);

    if(kind==="partly") return partlyFallback();

    if(kind==="fog") return base(`
      <defs>
        <linearGradient id="fg_${uid}" x1="0" x2="1">
          <stop offset="0" stop-color="#EAF2FF"/>
          <stop offset="1" stop-color="#BFD8FF"/>
        </linearGradient>
      </defs>
      <rect x="10" y="14" width="44" height="36" rx="16" fill="url(#fg_${uid})" opacity=".95"/>
      <g fill="#9FB6D8" opacity=".98">
        <rect x="12" y="26" width="40" height="4" rx="2"/>
        <rect x="10" y="34" width="44" height="4" rx="2"/>
        <rect x="14" y="42" width="36" height="4" rx="2"/>
      </g>
    `);

    if(kind==="rain") return base(`
      <defs>
        <linearGradient id="cloud3_${uid}" x1="0" x2="1">
          <stop offset="0" stop-color="#EAF2FF"/>
          <stop offset="1" stop-color="#BFD8FF"/>
        </linearGradient>
        <linearGradient id="drop_${uid}" x1="0" x2="0" y1="0" y2="1">
          <stop offset="0" stop-color="#36C2FF"/>
          <stop offset="1" stop-color="#2563EB"/>
        </linearGradient>
      </defs>
      <g fill="url(#cloud3_${uid})">
        <ellipse cx="36" cy="24" rx="18" ry="10"/>
        <ellipse cx="22" cy="28" rx="14" ry="8"/>
      </g>
      <g fill="url(#drop_${uid})">
        <path d="M22 40c0 4-4 6-4 10 0 2 4 4 4 4s4-2 4-4c0-4-4-6-4-10z"/>
        <path d="M34 40c0 4-4 6-4 10 0 2 4 4 4 4s4-2 4-4c0-4-4-6-4-10z"/>
        <path d="M46 40c0 4-4 6-4 10 0 2 4 4 4 4s4-2 4-4c0-4-4-6-4-10z"/>
      </g>
    `);

    if(kind==="snow") return base(`
      <defs>
        <linearGradient id="cloud4_${uid}" x1="0" x2="1">
          <stop offset="0" stop-color="#EAF2FF"/>
          <stop offset="1" stop-color="#BFD8FF"/>
        </linearGradient>
      </defs>
      <g fill="url(#cloud4_${uid})">
        <ellipse cx="36" cy="24" rx="18" ry="10"/>
        <ellipse cx="22" cy="28" rx="14" ry="8"/>
      </g>
      <g fill="#D7F0FF">
        <circle cx="22" cy="46" r="2.2"/><circle cx="32" cy="50" r="2.2"/>
        <circle cx="42" cy="46" r="2.2"/><circle cx="50" cy="50" r="2.2"/>
      </g>
    `);

    if(kind==="thunder") return base(`
      <defs>
        <linearGradient id="cloud5_${uid}" x1="0" x2="1">
          <stop offset="0" stop-color="#EAF2FF"/>
          <stop offset="1" stop-color="#BFD8FF"/>
        </linearGradient>
        <linearGradient id="bolt_${uid}" x1="0" x2="0" y1="0" y2="1">
          <stop offset="0" stop-color="#FFE08A"/>
          <stop offset="1" stop-color="#FFB020"/>
        </linearGradient>
      </defs>
      <g fill="url(#cloud5_${uid})">
        <ellipse cx="36" cy="24" rx="18" ry="10"/>
        <ellipse cx="22" cy="28" rx="14" ry="8"/>
      </g>
      <polygon points="30,38 40,38 32,56 36,44 26,44" fill="url(#bolt_${uid})"/>
    `);

    // Any unmapped code -> "partly" instead of grey block
    return partlyFallback();
  }

  function weatherCodeToText(code){
    const map = {0:"CLEAR",1:"MOSTLY CLEAR",2:"PARTLY CLOUDY",3:"OVERCAST",45:"FOG",48:"RIME FOG",
      51:"LIGHT DRIZZLE",53:"DRIZZLE",55:"HEAVY DRIZZLE",56:"FREEZING DRIZZLE",57:"HEAVY FREEZING DRIZZLE",
      61:"LIGHT RAIN",63:"RAIN",65:"HEAVY RAIN",66:"FREEZING RAIN",67:"HEAVY FREEZING RAIN",
      71:"LIGHT SNOW",73:"SNOW",75:"HEAVY SNOW",77:"SNOW GRAINS",
      80:"RAIN SHOWERS",81:"SHOWERS",82:"STRONG SHOWERS",
      85:"SNOW SHOWERS",86:"HEAVY SNOW SHOWERS",95:"THUNDERSTORM",96:"T-STORM WITH HAIL",99:"SEVERE T-STORM"};
    const wc = Number(code);
    return map[wc] ?? `WEATHER (${wc})`;
  }

  function dayLabel(isoDate){
    return new Date(isoDate+"T00:00:00").toLocaleDateString([], {weekday:"short"}).toUpperCase();
  }

  function windDirText(deg){
    if(deg==null || isNaN(deg)) return "—";
    const dirs=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"];
    return dirs[Math.round(deg/22.5)%16];
  }

  function uvHint(uv){
    if(uv==null||isNaN(uv)) return "—";
    if(uv<3) return "LOW";
    if(uv<6) return "MOD";
    if(uv<8) return "HIGH";
    if(uv<11) return "V HIGH";
    return "EXTREME";
  }

  function headlineFor(c){
    const code=Number(c.weather_code), wind=Number(c.wind_speed_10m??0), precip=Number(c.precipitation??0);
    if([95,96,99].includes(code)) return "ALERT: THUNDERSTORM CONDITIONS";
    if(precip>=2) return "WET ROADS: MODERATE RAIN POSSIBLE";
    if([71,73,75,85,86].includes(code)) return "WINTRY: SNOW SHOWERS IN THE AREA";
    if([45,48].includes(code)) return "VISIBILITY: PATCHY FOG";
    if(wind>=35) return "BREEZY: GUSTY WINDS EXPECTED";
    if(code===0) return "CLEAR SKIES: GREAT CONDITIONS";
    return "WEATHER UPDATE: STAY PREPARED";
  }

  function findStartIndex(times){
    const now = new Date();
    const nowKey = now.toISOString().slice(0,10) + "T" + String(now.getHours()).padStart(2,"0");
    let start = 0;
    for(let i=0;i<times.length;i++){
      if(String(times[i]).slice(0,13) >= nowKey){ start=i; break; }
    }
    return start;
  }

  function renderHourly(data){
    const hourlyEl=el("hourly");
    hourlyEl.innerHTML="";

    const times=data.hourly?.time || [];
    const temp=data.hourly?.temperature_2m || [];
    const code=data.hourly?.weather_code || [];
    const precipMM = data.hourly?.precipitation;
    const precipProb = data.hourly?.precipitation_probability;

    const start = findStartIndex(times);

    // ===== Hourly tiles: uses SLOTS =====
    for(let i=start; i<Math.min(start+SLOTS, times.length); i++){
      const t = new Date(times[i]);
      const label = t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
      const pmm = Number(precipMM?.[i] ?? 0);
      const ppr = precipProb?.[i];
      const mini = (ppr != null && !isNaN(ppr)) ? `POP ${Math.round(ppr)}%` : `P ${pmm.toFixed(1)} mm`;

      const item=document.createElement("div");
      item.className="h-item";
      item.innerHTML=`
        <div class="h-time">${label}</div>
        <div class="h-ico">${svgFor(code[i], 40)}</div>
        <div class="h-temp">${Math.round(Number(temp[i] ?? 0))}°</div>
        <div class="h-mini">${mini}</div>
      `;
      hourlyEl.appendChild(item);
    }

    // ===== Precip: uses SLOTS =====
    const bars=el("bars");
    const labels=el("barLabels");
    const banner=el("precipBanner");
    const mode=el("precipMode");

    bars.innerHTML="";
    labels.innerHTML="";

    let series = null;
    let isProb = false;

    if (Array.isArray(precipProb) && precipProb.length) {
      series = precipProb.map(v => Number(v ?? 0));
      isProb = true;
      mode.textContent = "% (POP)";
    } else if (Array.isArray(precipMM) && precipMM.length) {
      series = precipMM.map(v => Number(v ?? 0));
      isProb = false;
      mode.textContent = "mm";
    } else {
      series = null;
      mode.textContent = "—";
    }

    if(!series){
      banner.textContent = "PRECIP DATA NOT AVAILABLE";
      for(let k=0; k<SLOTS; k++){
        const b=document.createElement("div");
        b.className="bar";
        b.style.height="34px";
        b.innerHTML = `<div class="bar-value">--</div>`;
        bars.appendChild(b);

        const lab=document.createElement("span");
        lab.textContent = (k % 2 === 0) ? "--" : "";
        labels.appendChild(lab);
      }
      setNowLineToFirstBar();
      return;
    }

    // Slice (SLOTS)
    const slice = [];
    for (let i=start; i<Math.min(start+SLOTS, times.length); i++) slice.push(Number(series[i] ?? 0));
    while (slice.length < SLOTS) slice.push(0);

    const max = Math.max(...slice, 0);

    banner.textContent = isProb
      ? (max < 5 ? "LOW CHANCE OF PRECIP (NEXT 12H)" : `MAX POP ${Math.round(max)}% (NEXT 12H)`)
      : (max < 0.1 ? "NO PRECIP EXPECTED (NEXT 12H)" : `MAX ${max.toFixed(1)} MM (NEXT 12H)`);

    // Scaling: keep visible even when quiet
    const scaleMax = isProb ? Math.max(20, max) : (max < 0.1 ? 1.0 : max);

    for(let k=0; k<SLOTS; k++){
      const val = Number(slice[k] ?? 0);
      const h = Math.max(34, Math.round((val/scaleMax)*120));

      const b=document.createElement("div");
      b.className="bar";
      b.style.height=`${Math.min(140,h)}px`;

      if(isProb){
        if(val >= 60) b.classList.add("heavy");
        else if(val >= 30) b.classList.add("moderate");
      } else {
        if(val >= 3) b.classList.add("heavy");
        else if(val >= 1) b.classList.add("moderate");
      }

      const txt = isProb ? `${Math.round(val)}%` : `${val.toFixed(1)}`;
      b.innerHTML = `<div class="bar-value">${txt}</div>`;
      bars.appendChild(b);

      const i = start + k;
      const lab=document.createElement("span");
      if(i < times.length){
        const t = new Date(times[i]);
        const hh = String(t.getHours()).padStart(2,"0");
        lab.textContent = (k % 2 === 0) ? hh : "";
      } else {
        lab.textContent = (k % 2 === 0) ? "--" : "";
      }
      labels.appendChild(lab);
    }

    setNowLineToFirstBar();
  }

  function renderForecast(data){
    const out=el("forecast");
    out.innerHTML="";

    const times=data.daily.time;
    const tmax=data.daily.temperature_2m_max;
    const tmin=data.daily.temperature_2m_min;
    const code=data.daily.weather_code;
    const psum=data.daily.precipitation_sum;

    for(let i=0;i<Math.min(7,times.length);i++){
      const tile=document.createElement("div");
      tile.className="f-tile";
      tile.innerHTML=`
        <div>
          <div class="f-day">${dayLabel(times[i])}</div>
          <div class="f-sub">P ${(Number(psum[i] ?? 0)).toFixed(1)} mm</div>
        </div>
        <div class="f-ico">${svgFor(code[i], 36)}</div>
        <div>
          <div class="f-desc">${weatherCodeToText(code[i])}</div>
          <div class="f-sub">${(Number(psum[i] ?? 0)) > 1 ? "WET PERIOD" : "LOW PRECIP"}</div>
        </div>
        <div class="f-temps">${Math.round(Number(tmax[i] ?? 0))}° / ${Math.round(Number(tmin[i] ?? 0))}°</div>
      `;
      out.appendChild(tile);
    }
  }

  async function loadWeather(){
    const {lat,lon,tz,label}=LOCATION;
    el("placeLabel").textContent = label;

    const url =
      `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`+
      `&current=temperature_2m,apparent_temperature,relative_humidity_2m,precipitation,wind_speed_10m,wind_direction_10m,wind_gusts_10m,weather_code,cloud_cover,uv_index,pressure_msl`+
      `&hourly=temperature_2m,weather_code,precipitation,precipitation_probability`+
      `&daily=weather_code,temperature_2m_max,temperature_2m_min,precipitation_sum`+
      `&timezone=${encodeURIComponent(tz)}`;

    const res = await fetch(url, {cache:"no-store"});
    if(!res.ok) throw new Error("Weather fetch failed");
    const data = await res.json();
    const c = data.current;

    el("temp").textContent = Math.round(Number(c.temperature_2m ?? 0));
    el("apparent").textContent = Math.round(Number(c.apparent_temperature ?? 0));
    el("wind").textContent = Math.round(Number(c.wind_speed_10m ?? 0));
    el("windDir").textContent = windDirText(c.wind_direction_10m);
    el("precip").textContent = (Number(c.precipitation ?? 0)).toFixed(1);

    el("humidity").textContent = Math.round(Number(c.relative_humidity_2m ?? 0));
    el("cloud").textContent = Math.round(Number(c.cloud_cover ?? 0));
    el("uv").textContent = (Number(c.uv_index ?? 0)).toFixed(1);
    el("uvHint").textContent = uvHint(c.uv_index);

    el("gust").textContent = Math.round(Number(c.wind_gusts_10m ?? 0));
    el("press").textContent = Math.round(Number(c.pressure_msl ?? 0));

    el("wxText").textContent = weatherCodeToText(c.weather_code);
    el("wxIcon").innerHTML = svgFor(c.weather_code, 118);
    el("headline").textContent = headlineFor(c);

    el("todayP").textContent = (Number(data.daily?.precipitation_sum?.[0] ?? 0)).toFixed(1);

    const updated = new Date(c.time);
    el("wxUpdated").textContent =
      `UPDATED ${updated.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`;

    renderHourly(data);
    renderForecast(data);

    el("status").textContent = "ONLINE";
  }

  function start(){
    try{
      // ✅ Push slot count into CSS for perfect alignment:
      // .bars / .bar-labels / .now-line should use: repeat(var(--slots), 1fr)
      document.documentElement.style.setProperty('--slots', SLOTS);

      tickClock();
      setInterval(tickClock, 1000);

      loadWeather().catch(showFatal);
      setInterval(() => loadWeather().catch(()=>{}), 5*60*1000);
    }catch(e){
      showFatal(e);
    }
  }

  document.addEventListener("DOMContentLoaded", start);
</script>
