function renderHourly(data){
  const hourlyEl = el("hourly");
  hourlyEl.innerHTML = "";

  const times = data.hourly?.time || [];
  const temp  = data.hourly?.temperature_2m || [];
  const code  = data.hourly?.weather_code || [];

  // Precip arrays
  const precipMM   = data.hourly?.precipitation;               // ✅ used for chart
  const precipProb = data.hourly?.precipitation_probability;   // ignored in chart

  const start = findStartIndex(times);

  // ===== Hourly tiles (SLOTS) =====
  for(let i=start; i<Math.min(start+SLOTS, times.length); i++){
    const t = new Date(times[i]);
    const label = t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});

    const pmm = Number(precipMM?.[i] ?? 0);
    const mini = `P ${pmm.toFixed(1)} mm`;

    const item = document.createElement("div");
    item.className = "h-item";
    item.innerHTML = `
      <div class="h-time">${label}</div>
      <div class="h-ico">${svgFor(code[i], 40)}</div>
      <div class="h-temp">${Math.round(Number(temp[i] ?? 0))}°</div>
      <div class="h-mini">${mini}</div>
    `;
    hourlyEl.appendChild(item);
  }

  // ===== Precip chart (SLOTS) - ✅ ALWAYS expected precip amount (mm) =====
  const bars   = el("bars");
  const labels = el("barLabels");
  const banner = el("precipBanner");
  const mode   = el("precipMode");

  bars.innerHTML = "";
  labels.innerHTML = "";

  mode.textContent = "mm";

  // Only use precipitation (mm) for the bars
  const series = (Array.isArray(precipMM) && precipMM.length)
    ? precipMM.map(v => Number(v ?? 0))
    : null;

  if(!series){
    banner.textContent = "PRECIP DATA NOT AVAILABLE";
    bars.style.opacity = "1";
    labels.style.opacity = "1";

    for(let k=0; k<SLOTS; k++){
      const b = document.createElement("div");
      b.className = "bar";
      b.style.height = "34px";
      b.innerHTML = `<div class="bar-value">--</div>`;
      bars.appendChild(b);

      const lab = document.createElement("span");
      lab.textContent = (k % 2 === 0) ? "--" : "";
      labels.appendChild(lab);
    }
    setNowLineToFirstBar();
    return;
  }

  // Slice out the next SLOTS hours worth of precip (mm)
  const slice = [];
  for (let i=start; i<Math.min(start+SLOTS, times.length); i++){
    slice.push(Number(series[i] ?? 0));
  }
  while (slice.length < SLOTS) slice.push(0);

  const max = Math.max(...slice, 0);

  // ✅ Broadcast-style messaging + subtle "dry period" treatment
  const isDryWindow = max < 0.1;

  banner.textContent = isDryWindow
    ? `DRY PERIOD (NEXT ${SLOTS}H)`
    : `MAX ${max.toFixed(1)} MM (NEXT ${SLOTS}H)`;

  // Fade the chart slightly if completely dry
  bars.style.opacity = isDryWindow ? "0.75" : "1";
  labels.style.opacity = isDryWindow ? "0.85" : "1";

  // Scaling: keep visible even when quiet
  const scaleMax = isDryWindow ? 1.0 : max;

  for(let k=0; k<SLOTS; k++){
    const val = Number(slice[k] ?? 0);

    // ✅ Height rule:
    // - Exactly 0.0 mm => almost invisible
    // - Otherwise => scale with a small minimum for readability
    let h;
    if (val === 0) {
      h = 6; // "almost nothing"
    } else {
      h = Math.max(12, Math.round((val / scaleMax) * 120));
    }

    const b = document.createElement("div");
    b.className = "bar";
    b.style.height = `${Math.min(140, h)}px`;

    // If dry hour, dim it further
    if (val === 0) {
      b.style.opacity = "0.35";
    }

    // mm thresholds (broadcast-ish)
    if(val >= 3) b.classList.add("heavy");
    else if(val >= 1) b.classList.add("moderate");

    // Hide the value label for 0.0 to keep things clean
    b.innerHTML = `<div class="bar-value">${val === 0 ? "" : val.toFixed(1)}</div>`;
    bars.appendChild(b);

    const idx = start + k;
    const lab = document.createElement("span");
    if(idx < times.length){
      const tt = new Date(times[idx]);
      const hh = String(tt.getHours()).padStart(2,"0");
      lab.textContent = (k % 2 === 0) ? hh : "";
    } else {
      lab.textContent = (k % 2 === 0) ? "--" : "";
    }
    labels.appendChild(lab);
  }

  setNowLineToFirstBar();
}
